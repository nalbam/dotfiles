# CLAUDE.md

이 파일은 Claude Code (claude.ai/code)가 모든 프로젝트에서 코드 작업을 수행할 때 따라야 할 가이드를 제공합니다.

# 전역 코드 가이드라인

**중요: 프로젝트별 문서(예: docs/, README.md)가 있으면 반드시 참조하세요.**

**중요: 새 코드를 작성하기 전에 유사한 기존 코드를 검색하고 일관된 패턴을 유지하세요.**

**중요: 필요한 작업만 수행하세요. 작업이 필요하지 않으면 중단하세요.**

## 마음가짐

- 시니어 엔지니어처럼 생각하세요.
- 성급하게 결론 내리지 말고 여러 접근 방식을 평가한 후 결정하세요.
- 문제 정의 → 작고 안전한 변경 → 검토 → 리팩토링 — 이 루프를 반복하세요.
- 변경 사항을 작고, 집중적이고, 점진적으로 유지하세요.

## 코드 변경 전

- 호출/참조 경로를 포함하여 관련 파일을 처음부터 끝까지 읽으세요.
- 정의, 참조, 호출 위치, 관련 테스트 및 설정을 찾으세요.
- 전체 파일을 읽지 않고 코드를 변경하지 마세요.
- 가정을 명확하게 기록하세요.

## 핵심 원칙

- **올바른 문제 해결**: 불필요한 복잡성이나 범위 확대를 피하세요.
- **표준 솔루션 선호**: 커스텀 코드를 작성하기 전에 잘 알려진 라이브러리와 패턴을 사용하세요.
- **코드 가독성 유지**: 명확한 네이밍, 논리적 구조를 사용하고 깊은 중첩을 피하세요.
- **명시적 에러 처리**: 특정 예외를 포착하고, 의미 있는 메시지와 함께 빠르게 실패하세요.
- **보안을 고려한 설계**: 입력을 검증하고, 최소 권한을 적용하며, 절대 비밀을 노출하지 마세요.
- **얕은 의존성 유지**: 강한 결합을 최소화하고 명확한 경계를 유지하세요.
- **근본 원인 해결**: 증상이 아닌 근본적인 문제를 해결하세요.

## 문제 해결 및 근본 원인 분석

문제를 해결할 때 다음의 체계적인 프로세스를 따르세요:

### 조사 단계
1. **재현**: 정확한 에러 메시지, 스택 트레이스, 환경 세부 정보를 문서화하세요
2. **조사**:
   - 에러 메시지를 주의 깊게 읽으세요 - 근본 원인이 포함되어 있는 경우가 많습니다
   - 로그에서 실패로 이어지는 패턴, 경고 또는 에러를 확인하세요
   - 진입점에서 실패 지점까지 실행 경로를 추적하세요
   - 최소한의 실험으로 가정을 검증하세요
3. **근본 원인**:
   - 근본적인 문제에 도달할 때까지 "왜?"를 5번 물어보세요
   - 증상과 원인을 구별하세요 (예: "API가 500을 반환" vs "연결 풀 고갈")
   - 일회성 실패가 아닌 시스템적 문제를 찾으세요
4. **수정**: 증상이 아닌 근본 원인을 해결하고, 필요한 경우 임시 해결책을 문서화하세요
5. **검증**: 철저히 테스트하고, 회귀 테스트를 추가하고, 다른 곳에서 유사한 문제가 있는지 확인하세요

### 예시
**증상**: 프로덕션에서 간헐적인 충돌 발생
**나쁜 접근**: 에러 핸들링 추가 + 자동 재시작
**좋은 접근**: 프로파일링 → 메모리 누수 식별 (임시 파일 미정리) → 정리 로직 수정 + 제한 추가 → 부하 테스트로 검증

## 파일 크기 가이드라인

- 소스 코드 파일을 800줄 이하로 유지하세요 (절대 최대값).
- 일반적인 파일은 200-400줄이어야 합니다.
- 파일이 500줄 이상에 접근하면 리팩토링을 고려하세요.
- 큰 컴포넌트를 더 작고 집중된 모듈로 분할하세요.

## 함수 크기 가이드라인

- 함수를 50줄 이하로 유지하세요.
- 로직이 복잡해지면 헬퍼 함수를 추출하세요.
- 단일 책임 원칙: 하나의 함수, 하나의 목적.

## 테스트 전략

- **단위 테스트**: 로직을 격리하여 테스트, 빠름 (<10ms), 결정적
- **통합 테스트**: 현실적인 시나리오로 컴포넌트 상호작용 테스트
- **커버리지**: 핵심 로직 80% 이상, 중요 경로 100% 목표
- **버그 수정**: 회귀 테스트 필수 포함
- **의존성**: 외부 서비스는 목(mock)/스텁(stub) 사용
- **독립성**: 테스트는 상태를 공유하거나 실행 순서에 의존하지 않아야 함
- 테스트를 읽기 쉽게 유지 - 문서 역할을 합니다

## 문서화

- 자체 설명 코드 작성: 명확한 네이밍, 논리적 구조
- 명확하지 않은 로직에만 주석 추가 ("왜"를 설명하고, "무엇"은 설명하지 않음)
- README.md를 설정 지침, 사용 예시, 아키텍처 개요로 최신 상태로 유지
- API를 요청/응답 예시 및 에러 케이스로 문서화
- 동작을 변경하거나 기능을 추가할 때 문서 업데이트
- 오래된 주석 방지 - 잘못된 정보를 남기기보다 삭제

## 버전 관리

- **커밋**:
  - 단일 목적을 가진 작고 원자적인 변경
  - 명령형 분위기 사용: "Fix bug" (o), "Fixed bug" (x)
  - 형식: "동사 + 무엇 + 명확하지 않으면 왜"
  - 좋음: "Add retry logic to handle network timeouts"
  - 나쁨: "Update code", "Fix stuff", "WIP"
- **브랜치**: main에서 분기한 단기 피처 브랜치
- **풀 리퀘스트**:
  - PR당 하나의 기능, 제출 전 셀프 리뷰
  - 설명, 테스트 단계 포함, UI 변경 시 스크린샷 포함
- **모범 사례**:
  - 비밀, 바이너리, 생성된 파일을 커밋하지 마세요
  - 공유 브랜치에 강제 푸시 피하세요
  - 로컬 브랜치 리베이스, main에 병합

## 코드 리뷰 및 협업

- **제출 전**:
  - 먼저 자신의 diff를 검토하세요
  - 테스트 통과 및 린트 확인
  - 디버그 코드, console.log, TODO 확인
- **리뷰어로서**:
  - 로직, 엣지 케이스, 유지보수성에 집중
  - 비판만 하지 말고 질문하세요
  - 변경 사항을 이해하고 검증한 경우에만 승인
- **피드백 받기**:
  - 신속하고 전문적으로 응답
  - 자신의 논리를 설명하되, 더 나은 접근 방식에 개방적이어야 함
  - 해결한 후에만 대화를 해결됨으로 표시

## 보안 규칙

- 코드, 로그 또는 커밋에서 비밀을 노출하지 마세요.
- 모든 입력을 검증, 살균 및 인코딩하세요.
- 최소 권한 원칙을 적용하세요.
- 민감한 데이터를 로깅하지 마세요.

## 피해야 할 안티패턴

### 코드 품질
- 전체 컨텍스트를 읽지 않고 코드 수정
- 실패, 경고 또는 엣지 케이스 무시
- 조기 최적화 또는 추상화
- 광범위한 예외 핸들러 사용

### 문제 해결
- 근본 원인을 이해하지 않고 빠른 수정
- 원인을 해결하는 대신 증상 치료 (모든 곳에 try-catch)
- 첫 번째 그럴듯한 설명에서 멈춤
- 수정 구현 후 검증 생략
